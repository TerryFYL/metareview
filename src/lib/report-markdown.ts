import type { MetaAnalysisResult, EggersTest, BeggsTest, SubgroupAnalysisResult, SensitivityResult, PICO, MetaRegressionResult, GradeAssessment, InfluenceDiagnostic, RobAssessments, RobDomain, Study, CumulativeResult, DoseResponseResult } from './types';
import type { TrimAndFillResult } from './statistics/publication-bias';
import type { PRISMAData } from '../components/PRISMAFlow';
import type { ReportSections } from './report-export';
import { defaultReportSections } from './report-export';
import { calculateNNT, isLogScale, galbraithPlotData, isBinaryData, labbeePlotData, baujatPlotData } from './statistics';

interface MarkdownReportData {
  title: string;
  pico: PICO;
  result: MetaAnalysisResult;
  eggers: EggersTest | null;
  beggs?: BeggsTest | null;
  subgroupResult: SubgroupAnalysisResult | null;
  sensitivityResults: SensitivityResult[];
  trimFillResult?: TrimAndFillResult | null;
  metaRegression?: MetaRegressionResult | null;
  influenceDiagnostics?: InfluenceDiagnostic[];
  gradeAssessment?: GradeAssessment | null;
  robAssessments?: RobAssessments;
  studies?: Study[];
  cumulativeResults?: CumulativeResult[];
  doseResponseResult?: DoseResponseResult | null;
  prisma?: PRISMAData;
  sections?: ReportSections;
}

const fmt = (n: number, d = 2) => isFinite(n) ? n.toFixed(d) : '—';
const fmtP = (p: number) => !isFinite(p) ? '—' : p < 0.001 ? '< 0.001' : p.toFixed(3);
/** Escape markdown pipe characters in table cell content */
const escMd = (s: string) => s.replace(/\|/g, '\\|');

export function generateReportMarkdown(data: MarkdownReportData): string {
  const { result, eggers, beggs, subgroupResult, sensitivityResults, trimFillResult, metaRegression, influenceDiagnostics, gradeAssessment, robAssessments, studies, cumulativeResults, doseResponseResult, prisma } = data;
  const sec = data.sections || defaultReportSections;
  const measure = result.measure;
  const log = isLogScale(measure);
  const lines: string[] = [];

  lines.push(`# ${data.title || 'Meta-Analysis Report'}`);
  lines.push(`\n*Generated by MetaReview (https://metareview.cc) — ${new Date().toISOString().split('T')[0]}*\n`);

  // PICO
  if (sec.pico && (data.pico.population || data.pico.intervention)) {
    lines.push('## PICO\n');
    lines.push(`| Component | Description |`);
    lines.push(`|-----------|-------------|`);
    if (data.pico.population) lines.push(`| **Population** | ${data.pico.population} |`);
    if (data.pico.intervention) lines.push(`| **Intervention** | ${data.pico.intervention} |`);
    if (data.pico.comparison) lines.push(`| **Comparison** | ${data.pico.comparison} |`);
    if (data.pico.outcome) lines.push(`| **Outcome** | ${data.pico.outcome} |`);
    lines.push('');
  }

  // PRISMA Flow Summary
  if (sec.prisma && prisma) {
    const n = (val: string) => val.trim();
    const items: [string, string][] = [];
    if (n(prisma.dbRecords)) items.push(['Records from databases', n(prisma.dbRecords)]);
    if (n(prisma.otherRecords)) items.push(['Records from other sources', n(prisma.otherRecords)]);
    if (n(prisma.duplicatesRemoved)) items.push(['After duplicates removed', n(prisma.duplicatesRemoved)]);
    if (n(prisma.recordsScreened)) items.push(['Records screened', n(prisma.recordsScreened)]);
    if (n(prisma.recordsExcluded)) items.push(['Records excluded', n(prisma.recordsExcluded)]);
    if (n(prisma.fullTextAssessed)) items.push(['Full-text articles assessed', n(prisma.fullTextAssessed)]);
    if (n(prisma.fullTextExcluded)) items.push(['Full-text articles excluded', n(prisma.fullTextExcluded)]);
    if (prisma.fullTextExcludeReasons) items.push(['Exclusion reasons', prisma.fullTextExcludeReasons]);
    if (n(prisma.qualitativeSynthesis)) items.push(['Studies in qualitative synthesis', n(prisma.qualitativeSynthesis)]);
    if (n(prisma.quantitativeSynthesis)) items.push(['Studies in quantitative synthesis', n(prisma.quantitativeSynthesis)]);
    if (items.length > 0) {
      lines.push('## PRISMA 2020 Flow Summary\n');
      lines.push('| Stage | Count |');
      lines.push('|-------|-------|');
      for (const [label, val] of items) {
        lines.push(`| ${label} | ${escMd(val)} |`);
      }
      lines.push('');
    }
  }

  // Overall results
  if (sec.overall) {
    lines.push('## Overall Results\n');
    const r = result;
    const nullVal = log ? 1 : 0;
    lines.push(`- **Effect measure**: ${measure}`);
    lines.push(`- **Model**: ${r.model === 'fixed' ? 'Fixed-effects' : 'Random-effects (DerSimonian-Laird)'}`);
    lines.push(`- **Number of studies**: ${r.studies.length}`);
    lines.push(`- **Pooled estimate**: ${fmt(r.effect)} (95% CI: ${fmt(r.ciLower)}–${fmt(r.ciUpper)})`);
    lines.push(`- **p-value**: ${fmtP(r.pValue)}`);
    lines.push(`- **Heterogeneity**: Q = ${fmt(r.heterogeneity.Q)}, df = ${r.studies.length - 1}, p = ${fmtP(r.heterogeneity.pValue)}`);
    lines.push(`- **I²**: ${fmt(r.heterogeneity.I2, 1)}%`);
    lines.push(`- **τ²**: ${fmt(r.heterogeneity.tau2, 4)}`);
    if (r.predictionInterval) {
      lines.push(`- **Prediction interval**: ${fmt(r.predictionInterval.lower)}–${fmt(r.predictionInterval.upper)}`);
    }

    // NNT/NNH
    if (studies) {
      const nnt = calculateNNT(r, studies);
      if (nnt) {
        lines.push(`- **${nnt.isHarm ? 'NNH' : 'NNT'}**: ${fmt(nnt.nnt, 1)} (95% CI: ${nnt.nntCILower === Infinity ? '∞' : fmt(nnt.nntCILower, 1)}–${nnt.nntCIUpper === Infinity ? '∞' : fmt(nnt.nntCIUpper, 1)})`);
      }
    }

    lines.push('');

    // Interpretation
    if (sec.interpretation) {
      const direction = r.effect > nullVal ? 'higher' : 'lower';
      const sig = r.pValue < 0.05 ? 'statistically significant' : 'not statistically significant';
      lines.push(`**Interpretation**: The pooled ${measure} is ${fmt(r.effect)} (95% CI: ${fmt(r.ciLower)}–${fmt(r.ciUpper)}), which is ${sig} (p = ${fmtP(r.pValue)}). The point estimate suggests a ${direction} effect in the intervention group. Heterogeneity is ${r.heterogeneity.I2 < 25 ? 'low' : r.heterogeneity.I2 < 75 ? 'moderate' : 'high'} (I² = ${fmt(r.heterogeneity.I2, 1)}%).\n`);
    }
  }

  // Study table
  if (sec.studyTable && result.studies.length > 0) {
    lines.push('## Individual Studies\n');
    const useRandom = result.model === 'random';
    lines.push(`| Study | ${measure} | 95% CI | Weight |`);
    lines.push(`|-------|${'-'.repeat(measure.length + 2)}|--------|--------|`);
    for (const s of result.studies) {
      const w = useRandom ? s.weightRandom : s.weightFixed;
      lines.push(`| ${escMd(s.name)} | ${fmt(s.yi)} | ${fmt(s.ciLower)}–${fmt(s.ciUpper)} | ${fmt(w, 1)}% |`);
    }
    lines.push('');
  }

  // Publication bias
  if ((sec.eggers && eggers) || (sec.beggs && beggs)) {
    lines.push('## Publication Bias\n');
    if (eggers) {
      lines.push(`- **Egger's test**: intercept = ${fmt(eggers.intercept, 3)}, t = ${fmt(eggers.tValue, 3)}, p = ${fmtP(eggers.pValue)}`);
      lines.push(`  - ${eggers.pValue < 0.05 ? '⚠️ Significant asymmetry detected' : 'No significant asymmetry'}`);
    }
    if (beggs) {
      lines.push(`- **Begg's test**: τ = ${fmt(beggs.tau, 3)}, p = ${fmtP(beggs.pValue)}`);
    }
    if (trimFillResult && trimFillResult.k0 > 0) {
      lines.push(`- **Trim-and-Fill**: ${trimFillResult.k0} imputed studies, adjusted estimate = ${fmt(trimFillResult.adjustedEffect)}`);
    }
    lines.push('');
  }

  // Contour-Enhanced Funnel Plot
  if (sec.contourFunnel && result.studies.length >= 3) {
    const studiesWithZ = result.studies.map(s => ({ name: s.name, z: Math.abs(s.yi / s.sei) }));
    const sig01 = studiesWithZ.filter(s => s.z >= 2.576).length;
    const sig05 = studiesWithZ.filter(s => s.z >= 1.96 && s.z < 2.576).length;
    const sig10 = studiesWithZ.filter(s => s.z >= 1.645 && s.z < 1.96).length;
    const nonsig = studiesWithZ.filter(s => s.z < 1.645).length;
    lines.push('## Contour-Enhanced Funnel Plot\n');
    lines.push(`| Significance Region | Studies |`);
    lines.push(`|---------------------|---------|`);
    lines.push(`| p < 0.01 | ${sig01} |`);
    lines.push(`| 0.01 ≤ p < 0.05 | ${sig05} |`);
    lines.push(`| 0.05 ≤ p < 0.10 | ${sig10} |`);
    lines.push(`| p ≥ 0.10 (non-significant) | ${nonsig} |`);
    if (nonsig === 0 && result.studies.length > 3) {
      lines.push(`\n⚠️ All studies fall in significant regions — potential publication bias.`);
    }
    lines.push('');
  }

  // Galbraith Plot
  if (sec.galbraith && result.studies.length >= 3) {
    const gData = galbraithPlotData(result.studies, result.summary);
    lines.push('## Galbraith Plot (Radial Plot)\n');
    if (gData.outliers.length > 0) {
      lines.push(`**Outliers** (outside ±2 confidence band): ${gData.outliers.join(', ')}\n`);
    } else {
      lines.push('All studies fall within the ±2 confidence band — no outliers detected.\n');
    }
  }

  // Subgroup analysis
  if (sec.subgroup && subgroupResult) {
    lines.push('## Subgroup Analysis\n');
    lines.push(`| Subgroup | k | ${measure} | 95% CI | I² |`);
    lines.push(`|----------|---|${'-'.repeat(measure.length + 2)}|--------|-----|`);
    for (const g of subgroupResult.subgroups) {
      lines.push(`| ${escMd(g.name)} | ${g.result.studies.length} | ${fmt(g.result.effect)} | ${fmt(g.result.ciLower)}–${fmt(g.result.ciUpper)} | ${fmt(g.result.heterogeneity.I2, 1)}% |`);
    }
    if (subgroupResult.test.pValue != null) {
      lines.push(`\nInteraction test: Q = ${fmt(subgroupResult.test.Q)}, p = ${fmtP(subgroupResult.test.pValue)}`);
    }
    lines.push('');
  }

  // Baujat Plot
  if (sec.baujat && result.studies.length >= 3) {
    const bData = baujatPlotData(result.studies, result.summary, result.heterogeneity.tau2);
    if (bData) {
      const influential = bData.points.filter(p => p.contribution > bData.meanContribution && p.influence > bData.meanInfluence);
      lines.push('## Baujat Plot\n');
      if (influential.length > 0) {
        lines.push(`**Studies with high contribution and influence**: ${influential.map(p => p.name).join(', ')}\n`);
        lines.push('These studies contribute disproportionately to overall heterogeneity and influence the pooled estimate.\n');
      } else {
        lines.push('No studies identified in the high-contribution/high-influence quadrant.\n');
      }
    }
  }

  // Sensitivity analysis
  if (sec.sensitivity && sensitivityResults.length > 0) {
    lines.push('## Sensitivity Analysis (Leave-One-Out)\n');
    lines.push(`| Omitted | ${measure} | 95% CI | I² |`);
    lines.push(`|---------|${'-'.repeat(measure.length + 2)}|--------|-----|`);
    for (const s of sensitivityResults) {
      lines.push(`| ${s.omittedStudy} | ${fmt(s.effect)} | ${fmt(s.ciLower)}–${fmt(s.ciUpper)} | ${fmt(s.I2, 1)}% |`);
    }
    lines.push('');
  }

  // Leave-One-Out Cross-Validation Summary
  if (sec.loo && sensitivityResults.length > 0) {
    const isRatio = measure === 'OR' || measure === 'RR' || measure === 'HR';
    const effects = sensitivityResults.map(r => r.effect);
    const minEffect = Math.min(...effects);
    const maxEffect = Math.max(...effects);
    const fmtLoo = (v: number) => !isFinite(v) ? '—' : isRatio ? v.toFixed(2) : v.toFixed(3);
    const influential = sensitivityResults.filter(s => {
      const dirChanged = isRatio ? (s.effect > 1) !== (result.effect > 1) : (s.effect > 0) !== (result.effect > 0);
      const origSig = isRatio ? (result.ciLower > 1 || result.ciUpper < 1) : (result.ciLower > 0 || result.ciUpper < 0);
      const newSig = isRatio ? (s.ciLower > 1 || s.ciUpper < 1) : (s.ciLower > 0 || s.ciUpper < 0);
      return dirChanged || origSig !== newSig;
    });
    lines.push('## Leave-One-Out Cross-Validation\n');
    lines.push(`Effect range when omitting each study: ${fmtLoo(minEffect)} to ${fmtLoo(maxEffect)}\n`);
    if (influential.length === 0) {
      lines.push('The pooled estimate is robust — no single study substantially alters the overall result.\n');
    } else {
      lines.push(`**Influential studies**: ${influential.map(s => s.omittedStudy).join(', ')} — removing these alters the direction or significance of the pooled estimate.\n`);
    }
  }

  // L'Abbé Plot
  if (sec.labbe && studies && studies.length > 0) {
    const binaryEntries = studies
      .filter(st => isBinaryData(st.data))
      .map(st => {
        const d = st.data as { events1: number; total1: number; events2: number; total2: number };
        return { name: st.name, events1: d.events1, total1: d.total1, events2: d.events2, total2: d.total2 };
      });
    if (binaryEntries.length > 0) {
      const lData = labbeePlotData(binaryEntries);
      if (lData && lData.points.length > 0) {
        lines.push("## L'Abbé Plot\n");
        lines.push(`- **Total studies**: ${lData.points.length}`);
        lines.push(`- **Favouring treatment** (below diagonal): ${lData.favoursTreatment}`);
        lines.push(`- **Favouring control** (above diagonal): ${lData.favoursControl}`);
        lines.push(`- **On diagonal** (no difference): ${lData.points.length - lData.favoursTreatment - lData.favoursControl}`);
        lines.push('');
      }
    }
  }

  // Meta-regression
  if (sec.metaReg && metaRegression) {
    lines.push('## Meta-Regression\n');
    lines.push(`- **Covariate**: ${metaRegression.covariate}`);
    lines.push(`- **Intercept**: ${fmt(metaRegression.intercept, 4)}`);
    lines.push(`- **Coefficient**: ${fmt(metaRegression.coefficient, 4)}`);
    lines.push(`- **p-value**: ${fmtP(metaRegression.pValue)}`);
    lines.push(`- **R²**: ${fmt((metaRegression.R2 ?? 0) * 100, 1)}%`);
    lines.push('');
  }

  // Influence diagnostics
  if (sec.influence && influenceDiagnostics && influenceDiagnostics.length > 0) {
    lines.push('## Influence Diagnostics\n');
    const k = influenceDiagnostics.length;
    const threshold = 4 / k;
    const influential = influenceDiagnostics.filter(d => d.cooksDistance > threshold);
    if (influential.length > 0) {
      lines.push(`**Potentially influential studies**: ${influential.map(d => d.name).join(', ')}\n`);
    } else {
      lines.push('No individually influential studies detected.\n');
    }
  }

  // Network Graph
  if (sec.network && result.studies.length >= 3) {
    const subgroups = new Set<string>();
    const comparisons = new Map<string, number>();
    for (const study of result.studies) {
      const parts = study.name.split(/\s+vs\.?\s+/i);
      if (parts.length >= 2) {
        const a = parts[0].trim();
        const b = parts[1].trim();
        subgroups.add(a);
        subgroups.add(b);
        const key = [a, b].sort().join(' vs ');
        comparisons.set(key, (comparisons.get(key) || 0) + 1);
      }
    }
    if (subgroups.size >= 2) {
      lines.push('## Network Graph\n');
      lines.push(`- **Interventions**: ${Array.from(subgroups).join(', ')}`);
      lines.push(`- **Direct comparisons**: ${comparisons.size}`);
      for (const [comp, count] of comparisons) {
        lines.push(`  - ${comp}: ${count} ${count === 1 ? 'study' : 'studies'}`);
      }
      lines.push('');
    }
  }

  // GRADE
  if (sec.grade && gradeAssessment) {
    lines.push('## GRADE Assessment\n');
    lines.push(`**Overall certainty**: ${gradeAssessment.overall.toUpperCase()}\n`);
    const GRADE_LABELS: Record<string, string> = {
      riskOfBias: 'Risk of Bias',
      inconsistency: 'Inconsistency',
      indirectness: 'Indirectness',
      imprecision: 'Imprecision',
      publicationBias: 'Publication Bias',
    };
    lines.push(`| Domain | Rating | Reason |`);
    lines.push(`|--------|--------|--------|`);
    for (const [key, factor] of Object.entries(gradeAssessment.factors)) {
      lines.push(`| ${GRADE_LABELS[key] || key} | ${factor.level} | ${factor.reasoning || '—'} |`);
    }
    lines.push('');
  }

  // RoB
  if (sec.rob && robAssessments && Object.keys(robAssessments).length > 0) {
    lines.push('## Risk of Bias\n');
    const DOMAINS: RobDomain[] = ['d1_randomization', 'd2_deviations', 'd3_missing', 'd4_measurement', 'd5_selection'];
    const DOMAIN_LABELS: Record<RobDomain, string> = {
      d1_randomization: 'Randomization', d2_deviations: 'Deviations', d3_missing: 'Missing data', d4_measurement: 'Measurement', d5_selection: 'Selection',
    };
    lines.push(`| Study | ${DOMAINS.map(d => DOMAIN_LABELS[d]).join(' | ')} | Overall |`);
    lines.push(`|-------|${DOMAINS.map(() => '---').join('|')}|---------|`);
    for (const [study, assessment] of Object.entries(robAssessments)) {
      const cells = DOMAINS.map(d => assessment.domains[d] || '—');
      lines.push(`| ${study} | ${cells.join(' | ')} | ${assessment.overall} |`);
    }
    lines.push('');
  }

  // Cumulative
  if (sec.cumulative && cumulativeResults && cumulativeResults.length > 0) {
    lines.push('## Cumulative Meta-Analysis\n');
    lines.push(`| Added Study | ${measure} | 95% CI |`);
    lines.push(`|-------------|${'-'.repeat(measure.length + 2)}|--------|`);
    for (const c of cumulativeResults) {
      lines.push(`| ${c.addedStudy} | ${fmt(c.effect)} | ${fmt(c.ciLower)}–${fmt(c.ciUpper)} |`);
    }
    lines.push('');
  }

  // Dose-Response Analysis
  if (sec.doseResponse && doseResponseResult) {
    const dr = doseResponseResult;
    lines.push('## Dose-Response Analysis\n');
    lines.push(`- **Model type**: ${dr.modelType}`);
    lines.push(`- **Dose levels**: ${dr.k}`);
    lines.push(`- **Linear coefficient (β₁)**: ${fmt(dr.beta1, 4)}`);
    if (dr.modelType === 'quadratic') {
      lines.push(`- **Quadratic coefficient (β₂)**: ${fmt(dr.beta2, 4)}`);
    }
    lines.push(`- **p-value (linear)**: ${fmtP(dr.pLinear)}`);
    lines.push(`- **R²**: ${fmt(isFinite(dr.R2) ? dr.R2 * 100 : NaN, 1)}%`);
    lines.push(`\n${dr.pLinear < 0.05 ? `A significant ${dr.modelType} dose-response relationship was detected (p = ${fmtP(dr.pLinear)}).` : `No significant dose-response relationship was detected (p = ${fmtP(dr.pLinear)}).`}`);
    lines.push('');
  }

  // Narrative Summary
  if (sec.narrative) {
    const het = result.heterogeneity;
    const k = result.studies.length;
    let text = `A ${result.model === 'random' ? 'random-effects' : 'fixed-effect'} meta-analysis of ${k} studies was performed. The pooled ${measure} was ${fmt(result.effect)} (95% CI: ${fmt(result.ciLower)}–${fmt(result.ciUpper)}; p ${fmtP(result.pValue) === '< 0.001' ? '< 0.001' : `= ${fmtP(result.pValue)}`}), ${result.pValue < 0.05 ? 'indicating a statistically significant effect' : 'showing no statistically significant effect'}.`;
    text += ` Heterogeneity was ${het.I2 < 25 ? 'low' : het.I2 < 50 ? 'moderate' : het.I2 < 75 ? 'substantial' : 'considerable'} (I² = ${fmt(het.I2, 1)}%, Q = ${fmt(het.Q)}, p ${fmtP(het.pValue) === '< 0.001' ? '< 0.001' : `= ${fmtP(het.pValue)}`}; τ² = ${fmt(het.tau2, 4)}).`;
    if (result.predictionInterval) {
      text += ` The 95% prediction interval was ${fmt(result.predictionInterval.lower)}–${fmt(result.predictionInterval.upper)}.`;
    }
    if (eggers) {
      text += ` Egger's test ${eggers.pValue < 0.05 ? 'indicated significant' : 'did not indicate'} funnel plot asymmetry (p = ${fmtP(eggers.pValue)}).`;
    }
    if (beggs) {
      text += ` Begg's test ${beggs.pValue < 0.05 ? 'revealed significant' : 'showed no significant'} evidence of publication bias (p = ${fmtP(beggs.pValue)}).`;
    }
    if (trimFillResult && trimFillResult.k0 > 0) {
      text += ` Trim-and-Fill estimated ${trimFillResult.k0} missing ${trimFillResult.k0 === 1 ? 'study' : 'studies'}; adjusted ${measure} = ${fmt(trimFillResult.adjustedEffect)}.`;
    }
    if (subgroupResult && subgroupResult.subgroups.length > 1) {
      const testSig = subgroupResult.test.pValue < 0.05;
      text += ` Subgroup interaction test ${testSig ? 'was significant' : 'was not significant'} (p ${fmtP(subgroupResult.test.pValue) === '< 0.001' ? '< 0.001' : `= ${fmtP(subgroupResult.test.pValue)}`}).`;
    }
    if (metaRegression) {
      text += ` Meta-regression with ${metaRegression.covariate} ${metaRegression.pValue < 0.05 ? 'identified a significant moderating effect' : 'did not identify a significant moderating effect'} (p = ${fmtP(metaRegression.pValue)}).`;
    }
    if (gradeAssessment) {
      text += ` GRADE certainty: ${gradeAssessment.overall}.`;
    }
    lines.push('## Narrative Summary\n');
    lines.push(text);
    lines.push('');
  }

  // Methods
  if (sec.methods) {
    lines.push('## Methods\n');
    lines.push(`This meta-analysis was conducted using MetaReview (https://metareview.cc). ${result.model === 'random' ? 'Random-effects model with DerSimonian-Laird estimator' : 'Fixed-effects model (inverse-variance method)'} was used. Effect sizes are reported as ${measure} with 95% confidence intervals. Heterogeneity was assessed using Cochran's Q test and the I² statistic.`);
    lines.push('');
  }

  lines.push('---\n');
  lines.push('*Note: Plots (forest plot, funnel plot, etc.) are available in the HTML export.*');

  return lines.join('\n');
}
